<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>从Erlang开始了解Actor模型</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css"><link rel="stylesheet" href="/css/progressjs.css"><script src="/js/progress.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-160006603-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-160006603-1');
</script><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"></head><body><script>if (document.readyState == 'loading') {
  progressJs().start()
}
document.addEventListener('readystatechange', (event) => {
  if (document.readyState == 'interactive') {
    progressJs().set(50)
  }
  if (document.readyState == 'complete') {
    progressJs().end()
  }
});
</script><div><div class="inner"><h2>从Erlang开始了解Actor模型</h2><p>Actor Model是一个宽泛的概念，早在上个世纪就被提出来，它将Actor视作一个整体，可以是原子变量，也可以是一个实体，也可以代表一个线程，Actor之间相互通信，每个Actor都有自己的状态，在接收到其他Actor的消息后可以改变自己的状态，或者做一些其他事情。一般提到Actor，会用Erlang、Elixir或Akka来举例，它们都在一定程度上实现了Actor模型。</p>
<p>Erlang是一门古老的编程语言，也是一门典型的受Actor Model启发的编程语言。单纯去理解概念是空泛的，从具体的、特定的语言入手也许能帮助我们探索这些理论。就像学习FP，选择Haskell要好过Java很多倍。Elixir是基于Erlang虚拟机的一门语言，与Erlang的关系类似Scala和Java的关系，也因此Erlang的语法相对简单和干净一点。</p>
<h3 id="Erlang"><a href="#Erlang" class="headerlink" title="Erlang"></a>Erlang</h3><p>Erlang的代码块以<code>.</code>结尾，代码块可能只有一行，也可以有多行，<code>.</code>的作用类似于<code>}</code>，只是Erlang里没有<code>{</code>。代码块内的语句以<code>,</code>结尾，意味一个语句的结束，相当于一些语言的<code>;</code>。</p>
<p>Erlang将一个程序文件定义为一个模块，在命令行中使用<code>c(test).</code>可以加载模块。模块名称必须和文件名称一致：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(test)</span>.</span><br></pre></td></tr></table></figure>
<p>文件头部需要定义程序export的函数，这是模块的出口：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">0</span>, ping/<span class="number">3</span>, pong/<span class="number">0</span>])</span>.</span><br></pre></td></tr></table></figure>
<p>这里导出了3个函数，方括号和其他语言一样表示数组，函数名称后面的<code>/0</code>、<code>/3</code>指函数参数的个数。start函数将作为程序的主入口，负责启动整个程序，ping负责发送消息，pong负责接收消息并做出响应。</p>
<p>Erlang里面有个<code>process</code>的概念，它不是线程，也不是指计算机层面的进程，它就是<code>process</code>，或者也能把它当做线程，但是要明白它和线程不一样。我们将启动两个process，一个负责ping，一个负责pong，模拟消息的传输和交互。可以类比启动了两个线程，一个负责生产，一个负责消费。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ping</span><span class="params">(<span class="number">0</span>, Pong_PID, StartTime)</span> -&gt;</span> </span><br><span class="line">    Pong_PID ! &#123;finished, StartTime&#125;;</span><br></pre></td></tr></table></figure>
<p>这是ping函数的第一部分，是ping函数的一个分支，接收3个参数，如果第一个参数是0，就会执行这个函数中的语句。第二个参数<code>Pong_PID</code>指包含pong的process，第三个参数指程序启动的时间，用于记录程序的运行时长。函数体内只有一个语句，<code>!</code>是发送消息的意思，意为将数据<code>{finished, StartTime}</code>发送到id为<code>Pong_PID</code>的process中，其中finished是一个<code>Atom</code>，作为标识发送到pong那里。Atom是Erlang的数据类型之一，相当于……不需要声明的常量。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ping</span><span class="params">(N, Pong_PID, StartTime)</span> -&gt;</span> </span><br><span class="line">    Pong_PID ! &#123;ping, self()&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        pong -&gt; </span><br><span class="line">            io:format(<span class="string">"~w~n"</span>, [N])</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    ping(N - <span class="number">1</span>, Pong_PID, StartTime).</span><br></pre></td></tr></table></figure>
<p>这是ping函数的第二部分，如果函数接收到的第一个参数不等于0，就会执行这个函数内的语句。这一部分函数在接收到请求后，首先会做和分支一同样的事情，就是把数据<code>{ping, self()}</code>发送给pong，区别在于这里的标识为<code>ping</code>而不是<code>finished</code>，pong那里会根据这个标识做不同的操作，至于第二个参数，<code>self()</code>会返回当前process的id，也就是把ping的id传给了pong，用以pong回复消息。pong会选择性的使用第二个参数。</p>
<p>把数据发送到pong之后，有一个<code>receive ... end</code>的代码段，这个代码段会阻塞当前程序的执行，直到当前process接收到数据。代码段里是一个简单的模式匹配，<code>pong</code>是一个Atom类型的变量，如果接收到pong这样的标识，就会执行<code>-&gt;</code>后面的语句。<code>io:format</code>是一个简单的格式化输出，把N的值打印到屏幕上。</p>
<p>receive结束之后，马上又调了一下ping自己，递归……直到N为0，也就是说ping和pong的交互会持续N次，<code>io:format</code>那里会把交互次数打印出来。这是ping函数的两个分支，pong函数和ping函数的程序类似：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">pong</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;finished, StartTime&#125; -&gt; </span><br><span class="line">            io:format(<span class="string">"The End"</span>);</span><br><span class="line">            io:format(<span class="string">"~w~n"</span>, [erlang:timestamp()]);</span><br><span class="line">            io:format(<span class="string">"~w~n"</span>, [StartTime]);</span><br><span class="line">        &#123;ping, Ping_PID&#125; -&gt;</span><br><span class="line">            Ping_PID ! pong,</span><br><span class="line">            pong()</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<p>pong函数在入参层面没有分支，但是receive里有两种匹配，如果接收到了结束标识finished，会把开始时间和结束时间都打印出来，然后程序结束。如果接收到的标识是ping而不是finished，首先给Ping_PID也就是ping的process一个pong的响应，然后调了一遍自己，相当于先发了一个消息出去，接着自己等待消息的回复，如果没有收到回复，它就一直等着。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    Pong_PID = spawn(test, pong, []),</span><br><span class="line">    spawn(test, ping, [<span class="number">10</span>, Pong_PID, erlang:timestamp()]).</span><br></pre></td></tr></table></figure>
<p>最后是start函数，程序的入口函数，spawn了两个process，这两个process分别单独地运行。当传入ping的第一个参数为10，ping和pong的交互将持续10次。</p>
<h3 id="交互速率"><a href="#交互速率" class="headerlink" title="交互速率"></a>交互速率</h3><p>以前听到过一个所谓的“大牛”讲，我们现在想要提高计算机的速率，瓶颈是什么呢，我们应该往哪个方向努力呢，应该是CPU的利用率，Actor是很快的，为什么快呢，因为一个Actor就是一个整体，一个Actor只在一个内核中运行，连CPU内核之间的交互都省了……这种说法的正确性可能有待验证，不过Actor是否真的快呢，我有点好奇，萌生了想要测试一下Actor速度的想法。</p>
<p>必须要说明的是，我也相当清楚，这种测试方法很不靠谱。</p>
<p>在Erlang程序里启动两个process，两个process之间相互通信，测试不同数量级的通信次数，记录下程序执行所花费的时间。与Erlang作为对比，在Java里启动两个线程，用线程的睡眠和唤醒实现线程间的通信。同样的，在Go语言里用两个协程通信。至于Akka……其实也是Actor的代表。下表是测试之后的结果，次数从1到1亿，时间单位为毫秒。</p>
<table class="table">
<thead>
<tr>
<th style="text-align:right">次数</th>
<th style="text-align:right">Erlang</th>
<th style="text-align:right">Java</th>
<th style="text-align:right">Go</th>
<th style="text-align:right">Akka</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td style="text-align:right">10</td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
<td style="text-align:right">7</td>
</tr>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">3</td>
<td style="text-align:right">4</td>
<td style="text-align:right">1</td>
<td style="text-align:right">17</td>
</tr>
<tr>
<td style="text-align:right">1,000</td>
<td style="text-align:right">26</td>
<td style="text-align:right">30</td>
<td style="text-align:right">4</td>
<td style="text-align:right">83</td>
</tr>
<tr style="background:#ffff0008;">
<td style="text-align:right">10,000</td>
<td style="text-align:right;"><span style="color:#0000ff99;">610</span></td>
<td style="text-align:right">168</td>
<td style="text-align:right">42</td>
<td style="text-align:right"><span style="color:#0000ff99;">225</span></td>
</tr>
<tr style="background:#ffff0008;">
<td style="text-align:right">100,000</td>
<td style="text-align:right">2783</td>
<td style="text-align:right"><span style="color:#0000ff99;">1295</span></td>
<td style="text-align:right">404</td>
<td style="text-align:right"><span style="color:#0000ff99;">674</span></td>
</tr>
<tr style="background:#ffff0008;">
<td style="text-align:right">1,000,000</td>
<td style="text-align:right">27,085</td>
<td style="text-align:right">11,300</td>
<td style="text-align:right"><span style="color:#0000ff99;">4489</span></td>
<td style="text-align:right;"><span style="color:#0000ff99;">3515</span></td>
</tr>
<tr>
<td style="text-align:right">10,000,000</td>
<td style="text-align:right">273,912</td>
<td style="text-align:right">107,673</td>
<td style="text-align:right">40,335</td>
<td style="text-align:right">29,368</td>
</tr>
<tr>
<td style="text-align:right">100,000,000</td>
<td style="text-align:right">2,851,680</td>
<td style="text-align:right">1,092,879</td>
<td style="text-align:right">482,196</td>
<td style="text-align:right">300,228</td>
</tr>
</tbody>
</table>

<p>本来尝试用Echarts之类渲染一下这些数据，方便对比，后来发现这些数据绘制出来的折线图并不友好。</p>
<p>总的来看，Erlang的速度是最慢的，这可能和Erlang历史悠久有关，也许是因为没有得到足够的优化，相信Elixir的速度会好一些。相较之下，Java的速度胜过Erlang，Go语言的速度胜过Java，这似乎是意料之中的事情。Java的耗时是Erlang的1/3，Go语言的耗时是Java的1/2。</p>
<p>最让人惊讶的在于，Akka的Actor速度竟然比Go语言的协程还要快。在交互1000次之前，Akka的速度比Erlang还要慢，在10K数量级的时候，它的速度超过了Erlang，在100K数量级的时候，速度超过了Java，直到1M数量级的时候，Akka超过了Go语言，并且一直保持领先。这是一个令人难以置信的结果，同样是运行在JVM上，Akka的耗时是Java的1/3，可能Java线程间的交互确实带来了很大的开销。</p>
<p>没有用Elixir做测试是一个遗憾。关于Akka为什快，和Actor模型到底有没有关系，有多大的关系，还需要进一步探索。</p>
<p>(The End)</p>
<h3 id="Akka"><a href="#Akka" class="headerlink" title="Akka"></a>Akka</h3><p>用来做测试的Akka程序是Akka官方的Hello Wrold程序，能看到明显的Actor模型的影子，尤其是<code>!</code>运算符和<code>receive</code>方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.typed.<span class="type">ActorRef</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.<span class="type">Behavior</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.scaladsl.<span class="type">Behaviors</span></span><br><span class="line"><span class="keyword">import</span> <span class="type">GreeterMain</span>.<span class="type">SayHello</span></span><br></pre></td></tr></table></figure>
<p>这是导入部分，如果使用VS Code之类的编辑器，这段代码还是很重要的。和Erlang的程序类似，有一个发消息的Greeter和一个接收并回复消息的GreeterBot，另外还有一个主方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Greet</span>(<span class="params">whom: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">Greeted</span>]</span>)</span></span><br><span class="line"><span class="class">  <span class="title">final</span> <span class="title">case</span> <span class="title">class</span> <span class="title">Greeted</span>(<span class="params">whom: <span class="type">String</span>, from: <span class="type">ActorRef</span>[<span class="type">Greet</span>]</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">apply</span>(<span class="params"></span>)</span>: <span class="type">Behavior</span>[<span class="type">Greet</span>] = </span><br><span class="line">    <span class="type">Behaviors</span>.receive &#123; (context, message) =&gt;</span><br><span class="line">      message.replyTo ! <span class="type">Greeted</span>(message.whom, context.self)</span><br><span class="line">      <span class="type">Behaviors</span>.same</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是发消息的Greeter，当Greeter作为函数被调用，会自动执行apply中的代码。apply方法是一个receive，和Erlang的receive一样会阻塞程序直到Actor接收到消息。replyTo是GreeterBot的”pid”，Greeter接收到消息后会回复消息给GreeterBot。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GreeterBot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(max: <span class="type">Int</span>) = &#123;</span><br><span class="line">    bot(<span class="number">0</span>, max)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">bot</span></span>(greetingCounter: <span class="type">Int</span>, max: <span class="type">Int</span>): <span class="type">Behavior</span>[<span class="type">Greeter</span>.<span class="type">Greeted</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.receive &#123; (context, message) =&gt;</span><br><span class="line">      <span class="keyword">val</span> n = greetingCounter + <span class="number">1</span></span><br><span class="line">      context.log.info(<span class="string">"&#123;&#125;"</span>, n)</span><br><span class="line">      <span class="keyword">if</span> (n &gt;= max) &#123;</span><br><span class="line">        context.log.info(<span class="string">"The End | &#123;&#125;"</span>, <span class="type">System</span>.currentTimeMillis() - startTime)</span><br><span class="line">        <span class="type">Behaviors</span>.stopped</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        message.from ! <span class="type">Greeter</span>.<span class="type">Greet</span>(message.whom, context.self)</span><br><span class="line">        bot(n, max)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是GreeterBot，和Erlang简洁的代码比起来，Scala冗长的类型声明可能显得有些……烦杂。GreeterBot接收到来自Greeter的消息后，判断n是否为max，如果已经执行够次数了，就停止，否则调用自己进行递归。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GreeterMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">apply</span>(<span class="params"></span>)</span>: <span class="type">Behavior</span>[<span class="type">SayHello</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup &#123; context =&gt;</span><br><span class="line">      <span class="keyword">val</span> greeter = context.spawn(<span class="type">Greeter</span>(), <span class="string">"greeter"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="type">Behaviors</span>.receiveMessage &#123; message =&gt;</span><br><span class="line">        <span class="keyword">val</span> replyTo = context.spawn(<span class="type">GreeterBot</span>(max = <span class="number">10</span>), message.name)</span><br><span class="line">        greeter ! <span class="type">Greeter</span>.<span class="type">Greet</span>(message.name, replyTo)</span><br><span class="line">        <span class="type">Behaviors</span>.same</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AkkaQuickstart</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> greeterMain = <span class="type">ActorSystem</span>(<span class="type">GreeterMain</span>(), <span class="string">"AkkaQuickStart"</span>)</span><br><span class="line">  greeterMain ! <span class="type">SayHello</span>(<span class="string">"Charles"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是主方法，看着可能也有点……长。继承于App的类是能够运行的主类，向Actor系统中注册了GreetMain，同时GreetMain的apply方法被执行了一次。GreetMain里spawn了两个process，和Erlang的程序行为是类似的。</p>
<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go语言的程序真的要简洁很多，这是程序头部：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxCount = <span class="number">100000000</span></span><br><span class="line"><span class="keyword">var</span> startTime = time.Now().UnixNano() / <span class="number">1e6</span></span><br></pre></td></tr></table></figure>
<p>定义了两个变量，一个是程序执行次数，一个是程序开始时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxCount; i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      &lt;- ch</span><br><span class="line">      ch &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      timeUsed := time.Now().UnixNano() / <span class="number">1e6</span> - startTime</span><br><span class="line">      fmt.Println(<span class="string">"The End | "</span>, timeUsed)</span><br><span class="line">      <span class="built_in">close</span>(ch)</span><br><span class="line">      <span class="built_in">close</span>(exit)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxCount; i++ &#123;</span><br><span class="line">      ch &lt;- <span class="literal">true</span></span><br><span class="line">      &lt;- ch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  &lt;- exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个协程，从channel中取数据和向channel中写数据交替。Go语言的程序看着清爽太多了，Scala扎眼睛。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java的冗长程度不比Scala轻。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread sender = <span class="keyword">new</span> Sender(lock);</span><br><span class="line">        Thread receiver = <span class="keyword">new</span> Receiver(lock);</span><br><span class="line">        sender.start();</span><br><span class="line">        receiver.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主方法里启动了两个线程，锁是共享资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> MAX_COUNT = <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">static</span> String status = <span class="keyword">new</span> String(<span class="string">"init"</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        status = <span class="string">"sent"</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            startTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= MAX_COUNT) &#123;</span><br><span class="line">            status = <span class="string">"stop"</span>;</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis() - startTime;</span><br><span class="line">            System.out.println(<span class="string">"The End | "</span> + time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        status = <span class="string">"received"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message是临界资源，储存消息的内容。消息内容变更时做了一点其他的事情，把需要的日志打印到屏幕上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sender</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sender</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Message.getStatus().equals(<span class="string">"stop"</span>)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Message.getStatus().equals(<span class="string">"init"</span>) </span><br><span class="line">                  || Message.getStatus().equals(<span class="string">"received"</span>)) &#123;</span><br><span class="line">                    Message.send();</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Message.getStatus().equals(<span class="string">"stop"</span>)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Message.getStatus().equals(<span class="string">"sent"</span>)) &#123;</span><br><span class="line">                    Message.receive();</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sender和Receiver的程序类似，Sender先发送消息，然后wait，等着接收Receiver的消息，Receiver用while不停地判断有没有收到消息，如果有则回复消息，并且唤醒Sender，通知它该处理消息了，叫醒Sender后自己wait，等着Sender的反馈。</p>
<div class="align-right"><span>2020-03-31 12:47</span><span> 创建</span></div><div class="align-right"><span>2020-04-01 20:19</span><span> 更新</span></div></div></div></body></html>